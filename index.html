<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Route Sheet → Google Maps</title>

  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#0f0f0f">

  <style>
    body { font-family: Arial, sans-serif; margin: 16px; max-width: 980px; background:#0f0f0f; color:#eaeaea; }
    h1 { margin: 0 0 10px; }
    .muted { color: #b9b9b9; font-size: 13px; }
    .row { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    .card { border: 1px solid #2a2a2a; border-radius: 12px; padding: 12px; background:#151515; }
    label { font-weight: 700; display: block; margin: 10px 0 6px; }
    input[type="text"], textarea {
      width: 100%; padding: 10px; border: 1px solid #333; border-radius: 10px; box-sizing: border-box;
      background:#1b1b1b; color:#eaeaea;
    }
    textarea { min-height: 160px; }
    button { padding: 10px 12px; border: 0; border-radius: 10px; cursor: pointer; font-weight: 800; background:#d9d9d9; color:#111; }
    button:disabled { opacity: .55; cursor: not-allowed; }
    .btns { display: flex; flex-wrap: wrap; gap: 10px; margin-top: 10px; }
    .progress { height: 10px; background: #252525; border-radius: 999px; overflow: hidden; }
    .bar { height: 100%; width: 0%; background: #eaeaea; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .small { font-size: 12px; }
    .pill { display: inline-block; padding: 2px 8px; border: 1px solid #333; border-radius: 999px; font-size: 12px; color: #d0d0d0; }
    .warn { color: #ffb36b; font-size: 12px; }
    .ok { color: #42d392; font-size: 12px; }
    .checks { display:flex; gap:12px; flex-wrap:wrap; margin-top:10px; }
    .check { display:flex; align-items:center; gap:8px; font-size:12px; color:#d0d0d0; user-select:none; }
    .check input { transform: scale(1.1); }
  </style>
</head>
<body>
  <h1>Route Sheet → Google Maps</h1>
  <p class="muted">
    Upload route sheet photos (multiple) → click Analyze → stops are extracted (order preserved) → open turn-by-turn in Google Maps.
  </p>

  <div class="row">
    <div class="card">
      <label>1) Upload route sheet photos (multiple)</label>
      <input id="files" type="file" accept="image/*" multiple />

      <div style="margin-top:10px;">
        <div class="progress"><div id="bar" class="bar"></div></div>
        <div id="status" class="muted small" style="margin-top:6px;">Idle</div>
      </div>

      <div class="btns">
        <button id="geo">Use my current location as start</button>
        <button id="analyze" disabled>Analyze (OCR + Extract)</button>
      </div>

      <label class="small">Default city/state to append (recommended)</label>
      <input id="defaultPlace" type="text" placeholder="Example: Buffalo, NY   (or: Palm Coast, FL)" />

      <div class="checks">
        <label class="check">
          <input id="ignoreDepot" type="checkbox" checked />
          Ignore GARAGE/DEPOT/YARD/LOOP addresses
        </label>
        <label class="check">
          <input id="captureIntersections" type="checkbox" checked />
          Capture intersections (e.g., “Main St & Elmwood Ave”, “Forest Hill Dr @ Friar Way”)
        </label>
      </div>

      <div class="pill" style="margin-top:10px;">Start (GPS or type)</div>
      <input id="start" type="text" placeholder="Click 'Use my current location' or type a start address" />
      <div id="geoStatus" class="muted small"></div>

      <p class="muted small" style="margin-top:10px;">
        Calibrated for sheets that look like: <b>“6:52 am STOP 330 WEHRLE DR [N]”</b> and also “(stop) (12) … @ …”.
      </p>
    </div>

    <div class="card">
      <label>2) Destination (optional)</label>
      <input id="dest" type="text" value="" placeholder="Enter final destination (optional)" />

      <label style="margin-top:10px;">Stops (one per line, order preserved)</label>
      <textarea id="stops" placeholder="Stops will appear here after you click Analyze..."></textarea>

      <div class="btns">
        <button id="build" disabled>Build Google Maps Route</button>
        <button id="open" disabled>Open Google Maps</button>
      </div>

      <div style="margin-top:10px;">
        <div class="pill">Google Maps URL</div>
        <div id="url" class="mono small" style="margin-top:6px; word-break: break-all;"></div>
        <div id="routeNote" class="muted small"></div>
      </div>
    </div>
  </div>

  <div class="card" style="margin-top:12px;">
    <label>OCR Output (raw text from ALL images)</label>
    <textarea id="raw" placeholder="OCR text will show here after you click Analyze..."></textarea>
    <div id="limitNote" class="warn" style="margin-top:8px;"></div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
  <script>
    if ("serviceWorker" in navigator) {
      navigator.serviceWorker.register("sw.js").catch(()=>{});
    }

    const els = {
      files: document.getElementById('files'),
      analyze: document.getElementById('analyze'),
      geo: document.getElementById('geo'),
      start: document.getElementById('start'),
      dest: document.getElementById('dest'),
      defaultPlace: document.getElementById('defaultPlace'),
      ignoreDepot: document.getElementById('ignoreDepot'),
      captureIntersections: document.getElementById('captureIntersections'),
      raw: document.getElementById('raw'),
      stops: document.getElementById('stops'),
      build: document.getElementById('build'),
      open: document.getElementById('open'),
      url: document.getElementById('url'),
      status: document.getElementById('status'),
      bar: document.getElementById('bar'),
      geoStatus: document.getElementById('geoStatus'),
      routeNote: document.getElementById('routeNote'),
      limitNote: document.getElementById('limitNote'),
    };

    let mapsUrl = "";

    function setProgress(pct, msg) {
      els.bar.style.width = `${Math.max(0, Math.min(100, pct))}%`;
      if (msg) els.status.textContent = msg;
    }

    function normalizeStreetTypes(s) {
      return (s || "")
        .replace(/\bStreet\b/ig, "St")
        .replace(/\bAvenue\b/ig, "Ave")
        .replace(/\bRoad\b/ig, "Rd")
        .replace(/\bBoulevard\b/ig, "Blvd")
        .replace(/\bDrive\b/ig, "Dr")
        .replace(/\bLane\b/ig, "Ln")
        .replace(/\bParkway\b/ig, "Pkwy")
        .replace(/\bHighway\b/ig, "Hwy")
        .replace(/\bCourt\b/ig, "Ct")
        .replace(/\bPlace\b/ig, "Pl")
        .replace(/\bTerrace\b/ig, "Ter")
        .replace(/\bCircle\b/ig, "Cir")
        .replace(/\bDriveway\b/ig, "Drwy")
        .replace(/\bDRWY\b/ig, "Drwy")
        .replace(/\bAV\b/ig, "Ave")
        .replace(/\bHWY\b/ig, "Hwy");
    }

    function cleanLine(s) {
      return (s || "")
        .replace(/\r/g, "")
        .replace(/[|]+/g, " ")
        .replace(/\s+/g, " ")
        .trim();
    }

    function stripTimePrefix(line) {
      return line.replace(/^(\d{1,2}:\d{2}\s*(AM|PM|am|pm))\s+/, "");
    }

    function appendDefaultPlace(addr, defaultPlace) {
      const dp = (defaultPlace || "").trim();
      if (!dp) return addr;
      if (/,/.test(addr) || /\b[A-Z]{2}\b/.test(addr) || /\b\d{5}(-\d{4})?\b/.test(addr)) return addr;
      return addr + ", " + dp;
    }

    function normalizeHouseNumberWeirdness(s) {
      // "20/18 FARRAGUT DR" -> "2018 FARRAGUT DR"
      return s.replace(/^(\d{1,4})\s*\/\s*(\d{1,4})\b/, (m,a,b)=> `${a}${b}`);
    }

    function stripBracketDir(s) {
      // Remove trailing direction tags like [N], [E], [NE]
      return (s || "").replace(/\s*\[[A-Z]{1,3}\]\s*$/i, "").trim();
    }

    function looksLikeDepotText(t) {
      const U = (t||"").toUpperCase();
      return (
        U.includes("GARAGE") ||
        U.includes("DEPOT") ||
        U.includes("YARD") ||
        U.includes("BUS LOOP") ||
        U.includes("BUS COMPOUND") ||
        U.includes("COMPOUND") ||
        U.includes("PARKING LOT") ||
        U.includes("BUS BARN") ||
        U.includes("MAINTENANCE") ||
        U.includes("BUS GARAGE")
      );
    }

    function isTurnInstruction(line) {
      const U = (line||"").toUpperCase();
      return (
        U.startsWith("LEFT TURN") ||
        U.startsWith("RIGHT TURN") ||
        U.startsWith("CONTINUE ON") ||
        U.startsWith("START ON") ||
        U.startsWith("BEAR RIGHT") ||
        U.startsWith("BEAR LEFT") ||
        U.startsWith("SHARP RIGHT") ||
        U.startsWith("SHARP LEFT")
      );
    }

    function extractStopsFromText(rawText, opts) {
      const defaultPlace = opts.defaultPlace || "";
      const ignoreDepot = !!opts.ignoreDepot;
      const captureIntersections = !!opts.captureIntersections;

      const text = (rawText || "").replace(/\r/g, "\n");
      const lines = text.split("\n").map(cleanLine).filter(Boolean);

      // STREET TYPE list for quick matching
      const streetTypes = "(ST|STREET|AVE|AVENUE|RD|ROAD|BLVD|BOULEVARD|DR|DRIVE|LN|LANE|CT|COURT|PL|PLACE|TER|TERRACE|PKWY|PARKWAY|WAY|HWY|HIGHWAY|DRWY|DRIVEWAY|TRL|TRAIL|CIR|CIRCLE|CRVE|CURVE)";
      const singleAddrRe = new RegExp("^\\d{1,6}\\s+.+\\s+" + streetTypes + "\\b.*$", "i");

      // 1) Structured "STOP_01 ... ADDRESS:"
      const stopAddrRegex = /STOP_\d+\s*[\s\S]*?ADDRESS:\s*([^\n]+)/gi;
      const outA = [];
      const seenA = new Set();
      for (const m of text.matchAll(stopAddrRegex)) {
        let addr = normalizeStreetTypes(cleanLine(m[1] || ""));
        addr = normalizeHouseNumberWeirdness(addr);
        addr = stripBracketDir(addr);
        if (!addr) continue;
        if (ignoreDepot && looksLikeDepotText(addr)) continue;
        addr = appendDefaultPlace(addr, defaultPlace);
        const key = addr.toLowerCase();
        if (!seenA.has(key)) { seenA.add(key); outA.push(addr); }
      }
      if (outA.length > 0) return outA;

      // 2) Flagler style "(stop) (12) ... @ ..."
      const outB = [];
      const seenB = new Set();
      const stopLineParenRe = /(\(\s*stop\s*\)\s*\(\s*\d+\s*\))\s*(.+)$/i;
      for (let i=0;i<lines.length;i++) {
        let line = stripTimePrefix(lines[i]);
        line = normalizeStreetTypes(line);
        line = normalizeHouseNumberWeirdness(line);
        line = stripBracketDir(line);

        const m = line.match(stopLineParenRe);
        if (!m) continue;

        let loc = cleanLine(m[2] || "");
        if (!loc) continue;

        loc = loc.replace(/\s*@\s*/g, " & ").replace(/\s*\/\s*/g, " & ").replace(/\s+AT\s+/ig, " & ");
        if (ignoreDepot && looksLikeDepotText(loc)) continue;
        if (isTurnInstruction(loc)) continue;
        if (!captureIntersections && /\s&\s/.test(loc)) continue;

        loc = appendDefaultPlace(loc, defaultPlace);
        const key = loc.toLowerCase();
        if (seenB.has(key)) continue;
        seenB.add(key);
        outB.push(loc);
      }
      if (outB.length > 0) return outB;

      // 3) First Planning Solutions style: "6:52 am STOP 330 WEHRLE DR [N]"
      const outC = [];
      const seenC = new Set();
      const headerRe = /^(\d{1,2}:\d{2}\s*(?:AM|PM|am|pm))\s+(START|STOP|DEST|ORIGIN)\b\s*(.*)$/i;

      for (let i=0;i<lines.length;i++) {
        const line0 = normalizeStreetTypes(lines[i]);
        const m = line0.match(headerRe);
        if (!m) continue;

        const kind = (m[2] || "").toUpperCase();
        let payload = cleanLine(m[3] || "");
        payload = normalizeHouseNumberWeirdness(payload);
        payload = stripBracketDir(payload);

        // Block end (next header)
        let j = i + 1;
        while (j < lines.length) {
          const maybe = normalizeStreetTypes(lines[j]);
          if (maybe.match(headerRe)) break;
          j++;
        }

        if (kind !== "STOP") continue;

        if (!payload) continue;
        if (ignoreDepot && looksLikeDepotText(payload)) continue;

        // Prefer a clean address inside the STOP block (often in the PICKUP column)
        let best = "";
        const blockLines = lines.slice(i, j).map(x => normalizeStreetTypes(cleanLine(x)));

        let payloadStreetKey = "";
        const payloadStreetMatch = payload.match(/^\d.*?\s+([A-Z0-9\s]+?\s+(?:ST|AVE|RD|BLVD|DR|LN|CT|PL|TER|PKWY|WAY|HWY|DRWY|TRL|CIR|CRVE))\b/i);
        if (payloadStreetMatch) payloadStreetKey = cleanLine(payloadStreetMatch[1] || "").toUpperCase();

        for (const bl of blockLines) {
          if (!bl) continue;
          const bl2 = stripBracketDir(normalizeHouseNumberWeirdness(bl));
          if (isTurnInstruction(bl2)) continue;

          const U = bl2.toUpperCase();
          if (U.includes("PICKUP") || U.includes("DROPOFF")) continue;
          if (U.startsWith("DAYS:") || U.startsWith("SCHOOL:") || U.startsWith("GRADE:")) continue;
          if (!singleAddrRe.test(bl2)) continue;
          if (ignoreDepot && looksLikeDepotText(bl2)) continue;

          if (payloadStreetKey && U.includes(payloadStreetKey)) {
            best = bl2;
            break;
          }
          if (!best) best = bl2;
        }

        let stop = best || payload;

        if (captureIntersections) {
          stop = stop.replace(/\s*@\s*/g, " & ").replace(/\s*\/\s*/g, " & ").replace(/\s+AT\s+/ig, " & ");
        }

        stop = cleanLine(stop.replace(/\.+$/g, ""));
        stop = appendDefaultPlace(stop, defaultPlace);

        const key = stop.toLowerCase();
        if (seenC.has(key)) continue;
        seenC.add(key);
        outC.push(stop);
      }
      if (outC.length > 0) return outC;

      // 4) Fallback: address lines and loose intersections
      const addrLineRegex = new RegExp("^\\d{1,6}\\s+.+\\s+" + streetTypes + "\\b.*$", "i");
      const interRegexLoose = new RegExp("^(.+?\\s+" + streetTypes + ")\\s*(?:&|@|/|\\\\|\\bAND\\b|\\bAT\\b)\\s*(.+)$", "i");

      const out = [];
      const seen = new Set();

      for (let i=0;i<lines.length;i++) {
        let line = normalizeStreetTypes(lines[i]);
        line = normalizeHouseNumberWeirdness(line);
        line = stripBracketDir(line);
        if (!line) continue;

        if (isTurnInstruction(line)) continue;

        let stop = null;

        if (addrLineRegex.test(line)) {
          stop = line;
        } else if (captureIntersections) {
          const m = line.match(interRegexLoose);
          if (m) stop = cleanLine(m[1]) + " & " + cleanLine(m[2]);
        }

        if (!stop) continue;
        if (ignoreDepot && looksLikeDepotText(stop)) continue;

        stop = appendDefaultPlace(stop, defaultPlace);

        const key = stop.toLowerCase();
        if (seen.has(key)) continue;
        seen.add(key);
        out.push(stop);
      }

      return out;
    }

    function encodeForPath(s) {
      return encodeURIComponent(s).replace(/%20/g, "+");
    }

    function setAnalyzeEnabled() {
      els.analyze.disabled = !(els.files.files && els.files.files.length > 0);
    }

    els.files.addEventListener('change', () => {
      setAnalyzeEnabled();
      els.raw.value = "";
      els.stops.value = "";
      els.build.disabled = true;
      els.open.disabled = true;
      els.url.textContent = "";
      els.routeNote.textContent = "";
      els.limitNote.textContent = "";
      setProgress(0, "Ready");
    });

    async function requestLocation() {
      els.geoStatus.textContent = "Requesting location permission…";
      if (!navigator.geolocation) {
        els.geoStatus.innerHTML = `<span class="warn">Geolocation not supported in this browser.</span>`;
        return;
      }
      const tryGet = (options) => new Promise((resolve, reject) => {
        navigator.geolocation.getCurrentPosition(resolve, reject, options);
      });

      try {
        const pos = await tryGet({ enableHighAccuracy: true, timeout: 12000, maximumAge: 15000 });
        els.start.value = `${pos.coords.latitude},${pos.coords.longitude}`;
        els.geoStatus.innerHTML = `<span class="ok">Location set.</span>`;
        return;
      } catch (_) {}

      try {
        const pos = await tryGet({ enableHighAccuracy: false, timeout: 15000, maximumAge: 0 });
        els.start.value = `${pos.coords.latitude},${pos.coords.longitude}`;
        els.geoStatus.innerHTML = `<span class="ok">Location set.</span>`;
      } catch (e) {
        let msg = "Location denied/unavailable.";
        if (e && typeof e.code === "number") {
          if (e.code === 1) msg = "Location permission denied.";
          if (e.code === 2) msg = "Location unavailable.";
          if (e.code === 3) msg = "Location timed out.";
        }
        const isFile = window.location.protocol === "file:";
        els.geoStatus.innerHTML =
          `<span class="warn">${msg}${isFile ? " (Tip: open via https (GitHub Pages) or http://localhost for reliable GPS.)" : ""}</span>`;
      }
    }
    els.geo.addEventListener('click', requestLocation);

    els.analyze.addEventListener('click', async () => {
      const files = Array.from(els.files.files || []);
      if (!files.length) return;

      els.analyze.disabled = true;
      els.build.disabled = true;
      els.open.disabled = true;
      els.url.textContent = "";
      els.routeNote.textContent = "";
      els.limitNote.textContent = "";

      let combined = "";
      try {
        for (let i = 0; i < files.length; i++) {
          const f = files[i];
          setProgress(Math.round((i / files.length) * 100), `OCR image ${i+1} of ${files.length}…`);

          const { data } = await Tesseract.recognize(f, "eng", {
            logger: m => {
              if (m.status === "recognizing text") {
                const base = (i / files.length) * 100;
                const add = m.progress * (100 / files.length);
                setProgress(Math.round(base + add), `OCR ${i+1}/${files.length}: ${Math.round(m.progress*100)}%`);
              }
            }
          });

          combined += `\n\n----- IMAGE ${i+1} -----\n` + (data.text || "");
        }

        els.raw.value = combined.trim();
        setProgress(100, "OCR complete. Extracting stops…");

        const stops = extractStopsFromText(combined, {
          defaultPlace: els.defaultPlace.value || "",
          ignoreDepot: els.ignoreDepot.checked,
          captureIntersections: els.captureIntersections.checked
        });

        els.stops.value = stops.join("\n");

        if (stops.length === 0) {
          els.status.textContent = "No stops detected. Tip: set Default city/state (e.g., Buffalo, NY) and try again.";
          els.build.disabled = true;
        } else {
          els.status.textContent = `Extracted ${stops.length} stop(s). Review/edit if needed (order preserved).`;
          els.build.disabled = false;
        }

        if (stops.length > 8) {
          els.limitNote.textContent =
            "Heads-up: Google Maps may fail if there are too many stops in one route link. If that happens, split into two routes (e.g., stops 1–8 and 9–end).";
        }
      } catch (e) {
        console.error(e);
        els.status.textContent = "OCR failed. Try clearer images or higher contrast.";
      } finally {
        els.analyze.disabled = false;
        setAnalyzeEnabled();
      }
    });

    els.build.addEventListener('click', () => {
      const start = (els.start.value || "").trim();
      const dest = (els.dest.value || "").trim();
      const stops = els.stops.value.split(/\r?\n/).map(s => s.trim()).filter(Boolean);

      if (!start) {
        els.routeNote.innerHTML = `<span class="warn">Start is required. Click “Use my current location” or type a start address.</span>`;
        return;
      }
      if (stops.length === 0) {
        els.routeNote.innerHTML = `<span class="warn">No stops. Add at least one stop line.</span>`;
        return;
      }

      const partsRaw = [start, ...stops];
      if (dest) partsRaw.push(dest);

      const parts = partsRaw.map(encodeForPath);
      mapsUrl = "https://www.google.com/maps/dir/" + parts.join("/") + "?travelmode=driving";

      els.url.textContent = mapsUrl;
      els.open.disabled = false;
      els.routeNote.textContent = dest ? "Built route: Start → Stops → Destination (order preserved)." : "Built route: Start → Stops (order preserved).";
    });

    els.open.addEventListener('click', () => {
      if (!mapsUrl) return;
      window.open(mapsUrl, "_blank", "noopener,noreferrer");
    });

    setAnalyzeEnabled();
  </script>
</body>
</html>
