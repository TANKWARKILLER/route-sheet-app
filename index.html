<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Route Sheet → Google Maps</title>

  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#0f0f0f">

  <style>
    body { font-family: Arial, sans-serif; margin: 16px; max-width: 980px; background:#0f0f0f; color:#eaeaea; }
    h1 { margin: 0 0 10px; }
    .muted { color: #b9b9b9; font-size: 13px; }
    .row { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    .card { border: 1px solid #2a2a2a; border-radius: 12px; padding: 12px; background:#151515; }
    label { font-weight: 700; display: block; margin: 10px 0 6px; }
    input[type="text"], textarea {
      width: 100%; padding: 10px; border: 1px solid #333; border-radius: 10px; box-sizing: border-box;
      background:#1b1b1b; color:#eaeaea;
    }
    textarea { min-height: 160px; }
    button { padding: 10px 12px; border: 0; border-radius: 10px; cursor: pointer; font-weight: 800; background:#d9d9d9; color:#111; }
    button:disabled { opacity: .55; cursor: not-allowed; }
    .btns { display: flex; flex-wrap: wrap; gap: 10px; margin-top: 10px; }
    .progress { height: 10px; background: #252525; border-radius: 999px; overflow: hidden; }
    .bar { height: 100%; width: 0%; background: #eaeaea; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .small { font-size: 12px; }
    .pill { display: inline-block; padding: 2px 8px; border: 1px solid #333; border-radius: 999px; font-size: 12px; color: #d0d0d0; }
    .warn { color: #ffb36b; font-size: 12px; }
    .ok { color: #42d392; font-size: 12px; }
    .checks { display:flex; gap:12px; flex-wrap:wrap; margin-top:10px; }
    .check { display:flex; align-items:center; gap:8px; font-size:12px; color:#d0d0d0; user-select:none; }
    .check input { transform: scale(1.1); }
  </style>
</head>
<body>
  <h1>Route Sheet → Google Maps</h1>
  <p class="muted">
    Upload route sheet photos (multiple) → click Analyze → stops are extracted (order preserved) → open turn-by-turn in Google Maps.
  </p>

  <div class="row">
    <div class="card">
      <label>1) Upload route sheet photos (multiple)</label>
      <input id="files" type="file" accept="image/*" multiple />

      <div style="margin-top:10px;">
        <div class="progress"><div id="bar" class="bar"></div></div>
        <div id="status" class="muted small" style="margin-top:6px;">Idle</div>
      </div>

      <div class="btns">
        <button id="geo">Use my current location as start</button>
        <button id="analyze" disabled>Analyze (OCR + Extract)</button>
      </div>

      <label class="small">Default city/state to append (recommended)</label>
      <input id="defaultPlace" type="text" placeholder="Example: Buffalo, NY   (or: Palm Coast, FL)" />

      <div class="checks">
        <label class="check">
          <input id="ignoreDepot" type="checkbox" checked />
          Ignore GARAGE/DEPOT/YARD/LOOP addresses
        </label>
        <label class="check">
          <input id="captureIntersections" type="checkbox" checked />
          Capture intersections (e.g., “Main St & Elmwood Ave”, “Forest Hill Dr @ Friar Way”)
        </label>
      </div>

      <div class="pill" style="margin-top:10px;">Start (GPS or type)</div>
      <input id="start" type="text" placeholder="Click 'Use my current location' or type a start address" />
      <div id="geoStatus" class="muted small"></div>

      <p class="muted small" style="margin-top:10px;">
        Calibrated for sheets that look like: <b>“6:52 am STOP 330 WEHRLE DR [N]”</b> and also “(stop) (12) … @ …”.
      </p>
    </div>

    <div class="card">
      <label>2) Destination (optional)</label>
      <input id="dest" type="text" value="" placeholder="Enter final destination (optional)" />

      <label style="margin-top:10px;">Stops (one per line, order preserved)</label>
      <textarea id="stops" placeholder="Stops will appear here after you click Analyze..."></textarea>

      <div class="btns">
        <button id="build" disabled>Build Google Maps Route</button>
        <button id="open" disabled>Open Google Maps</button>
      </div>

      <div style="margin-top:10px;">
        <div class="pill">Google Maps URL</div>
        <div id="url" class="mono small" style="margin-top:6px; word-break: break-all;"></div>
        <div id="routeNote" class="muted small"></div>
      </div>
    </div>
  </div>

  <div class="card" style="margin-top:12px;">
    <label>OCR Output (raw text from ALL images)</label>
    <textarea id="raw" placeholder="OCR text will show here after you click Analyze..."></textarea>
    <div id="limitNote" class="warn" style="margin-top:8px;"></div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
  <script>
    if ("serviceWorker" in navigator) {
      navigator.serviceWorker.register("sw.js").catch(()=>{});
    }

    const els = {
      files: document.getElementById('files'),
      analyze: document.getElementById('analyze'),
      geo: document.getElementById('geo'),
      start: document.getElementById('start'),
      dest: document.getElementById('dest'),
      defaultPlace: document.getElementById('defaultPlace'),
      ignoreDepot: document.getElementById('ignoreDepot'),
      captureIntersections: document.getElementById('captureIntersections'),
      raw: document.getElementById('raw'),
      stops: document.getElementById('stops'),
      build: document.getElementById('build'),
      open: document.getElementById('open'),
      url: document.getElementById('url'),
      status: document.getElementById('status'),
      bar: document.getElementById('bar'),
      geoStatus: document.getElementById('geoStatus'),
      routeNote: document.getElementById('routeNote'),
      limitNote: document.getElementById('limitNote'),
    };

    let mapsUrl = "";

    function setProgress(pct, msg) {
      els.bar.style.width = `${Math.max(0, Math.min(100, pct))}%`;
      if (msg) els.status.textContent = msg;
    }

    function normalizeStreetTypes(s) {
      return (s || "")
        .replace(/\bStreet\b/ig, "St")
        .replace(/\bAvenue\b/ig, "Ave")
        .replace(/\bRoad\b/ig, "Rd")
        .replace(/\bBoulevard\b/ig, "Blvd")
        .replace(/\bDrive\b/ig, "Dr")
        .replace(/\bLane\b/ig, "Ln")
        .replace(/\bParkway\b/ig, "Pkwy")
        .replace(/\bHighway\b/ig, "Hwy")
        .replace(/\bCourt\b/ig, "Ct")
        .replace(/\bPlace\b/ig, "Pl")
        .replace(/\bTerrace\b/ig, "Ter")
        .replace(/\bCircle\b/ig, "Cir")
        .replace(/\bDriveway\b/ig, "Drwy")
        .replace(/\bDRWY\b/ig, "Drwy")
        .replace(/\bAV\b/ig, "Ave")
        .replace(/\bHWY\b/ig, "Hwy");
    }

    function normalizeSlashes(s) {
      // Keep slash-separated house numbers (e.g., 154/158/157 WALTON DR). Only normalize spacing around slashes.
      return (s || "").replace(/\s*\/\s*/g, "/");
    }

    function cleanLine(s) {
      return (s || "")
        .replace(/\r/g, "")
        .replace(/[|]+/g, " ")
        .replace(/\s+/g, " ")
        .trim();
    }

    function stripTimePrefix(line) {
      return line.replace(/^(\d{1,2}:\d{2}\s*(AM|PM|am|pm))\s+/, "");
    }

    function appendDefaultPlace(addr, defaultPlace) {
      const dp = (defaultPlace || "").trim();
      if (!dp) return addr;
      if (/,/.test(addr) || /\b[A-Z]{2}\b/.test(addr) || /\b\d{5}(-\d{4})?\b/.test(addr)) return addr;
      return addr + ", " + dp;
    }

    function stripBracketDir(s) {
      // Remove direction tags like [N], [E], [NE] (often followed by pickup counts)
      return (s || "").replace(/\s*\[[A-Z]{1,3}\]\s*/gi, " ").replace(/\s+/g, " ").trim();
    }

    function looksLikeDepotText(t) {
      const U = (t||"").toUpperCase();
      return (
        U.includes("GARAGE") ||
        U.includes("DEPOT") ||
        U.includes("YARD") ||
        U.includes("BUS LOOP") ||
        U.includes("BUS COMPOUND") ||
        U.includes("COMPOUND") ||
        U.includes("PARKING LOT") ||
        U.includes("BUS BARN") ||
        U.includes("MAINTENANCE") ||
        U.includes("BUS GARAGE")
      );
    }

    function isTurnInstruction(line) {
      const U = (line||"").toUpperCase();
      return (
        U.startsWith("LEFT TURN") ||
        U.startsWith("RIGHT TURN") ||
        U.startsWith("CONTINUE ON") ||
        U.startsWith("START ON") ||
        U.startsWith("BEAR RIGHT") ||
        U.startsWith("BEAR LEFT") ||
        U.startsWith("SHARP RIGHT") ||
        U.startsWith("SHARP LEFT")
      );
    }

    function extractStopsFromText(rawText, opts) {
      const defaultPlace = (opts && opts.defaultPlace) ? String(opts.defaultPlace).trim() : "";
      const ignoreDepot = !!(opts && opts.ignoreDepot);
      const captureIntersections = !!(opts && opts.captureIntersections);

      const text = (rawText || "").replace(/\r/g, "\n");
      const linesRaw = text.split("\n").map(cleanLine).filter(Boolean);

      // Helpers
      const streetTypes = [
        "ST","STREET","AVE","AV","AVENUE","RD","ROAD","BLVD","BOULEVARD","LN","LANE","DR","DRIVE",
        "CT","COURT","PL","PLACE","PKWY","PARKWAY","TER","TERRACE","CIR","CIRCLE","TRL","TRAIL",
        "HWY","HIGHWAY","WAY","SQ","SQUARE","RUN","PLZ","PLAZA","PT","POINT","BL","BAY","XING","CROSSING",
        "DRWY","DRIVEWAY","CRVE","CURVE"
      ];

      const typeRe = streetTypes.join("|");
      const hasStreetType = new RegExp("\\b(" + typeRe + ")\\b", "i");
      const looksLikeAddress = (s) => {
        if (!s) return false;
        const x = s.trim();

        // Must contain either a house-number-ish token OR an intersection marker
        const hasNum = /^\d{1,6}([\/-]\d{1,6})*/.test(x) || /\b\d{1,6}([\/-]\d{1,6})+\b/.test(x);
        const hasAt = /\s(@|AT)\s/i.test(x) || /\s&\s/.test(x);

        // Common stop rows are like: "330 WEHRLE DR [N]" or "FOREST HILL DR @ FRIAR WAY"
        if (hasAt) return true;
        if (hasNum && hasStreetType.test(x)) return true;

        return false;
      };

      const stripTrailingPickupCount = (s) => {
        // Removes a trailing lone pickup count like "... [E]  1"
        // but does NOT touch things like "APT 1" (rare on these sheets)
        return s.replace(/\s{2,}(\d{1,2})\s*$/, "");
      };

      const normalizeIntersection = (s) => {
        // Keep slash house numbers as-is. Only normalize intersection tokens.
        // Convert "X @ Y" or "X AT Y" to "X & Y" for Google Maps.
        if (!captureIntersections) return s;
        let x = s.replace(/\s+\@\s+/g, " & ").replace(/\s+\bAT\b\s+/gi, " & ");
        // If it already has &, leave it.
        return x;
      };

      // 0) First try: Structured "STOP_01 ... ADDRESS:" (your earlier Buffalo-style test sheets)
      const stopAddrRegex = /STOP_\d+\s*[\s\S]*?ADDRESS:\s*([^\n]+)/gi;
      const outStructured = [];
      const seenStructured = new Set();
      let m;
      while ((m = stopAddrRegex.exec(text)) !== null) {
        let addr = cleanLine(m[1]);
        addr = normalizeSlashes(addr);
        addr = stripBracketDir(addr);
        addr = stripTrailingPickupCount(addr);
        addr = normalizeIntersection(addr);
        if (!addr) continue;
        if (ignoreDepot && looksLikeDepotText(addr)) continue;
        addr = appendDefaultPlace(addr, defaultPlace);
        const key = addr.toLowerCase();
        if (!seenStructured.has(key)) { seenStructured.add(key); outStructured.push(addr); }
      }
      if (outStructured.length) return outStructured;

      // 1) General scanning for First Planning / Flagler style:
      // We look for lines containing STOP/(stop) and then grab the address on the same line
      // OR the next few lines.
      const out = [];
      const seen = new Set();

      // Common header-ish lines to ignore entirely
      const ignoreLineRe = /^(ROUTE:|BUS:|DRIVER:|ANCHOR:|START\s+TIME:|END\s+TIME:|TOTAL|DISTANCE:|ROUTE\s+DAYS:|SCHEDULE\s+DAY:|PAGE\s+\d+|BUS\s+DRIVER\s+DIRECTIONS|FIRST\s+PLANNING\s+SOLUTIONS|FLAGLER\s+COUNTY|SAN\s+BERNARDINO|NOTES:|PICK\s*UP|DROP\s*OFF)\b/i;

      for (let i = 0; i < linesRaw.length; i++) {
        let line = linesRaw[i];
        if (!line) continue;
        if (ignoreLineRe.test(line)) continue;

        // Normalize only safe things
        line = normalizeSlashes(line);
        line = stripBracketDir(line);
        line = stripTrailingPickupCount(line);

        const upper = line.toUpperCase();

        const hasStopKeyword =
          /\bSTOP\b/.test(upper) ||
          /\(\s*STOP\s*\)/.test(upper);

        if (!hasStopKeyword) continue;

        // Skip START/DEST rows (we treat those as optional destination, not pickups)
        if (/\bSTART\b/.test(upper) || /\bDEST\b/.test(upper) || /\bORIGIN\b/.test(upper) || /\bARRIVE\b/.test(upper) || /\bEND\b/.test(upper)) {
          continue;
        }

        // Attempt 1: address is on the same line after STOP token
        let candidate = "";
        // Remove leading time like "6:52 am"
        let noTime = line.replace(/^\s*\d{1,2}:\d{2}\s*(am|pm)?\s*/i, "").trim();

        // Remove "STOP" and any parenthetical stop numbers "(stop) (12)"
        noTime = noTime.replace(/\(\s*stop\s*\)\s*\(\s*\d+\s*\)\s*/i, "")
                       .replace(/\bSTOP\b\s*/i, "")
                       .replace(/^\(\s*\d+\s*\)\s*/,"")
                       .trim();

        // Some lines are like: "STOP 154/158/157 WALTON DR [E]"
        // After stripping, what's left should be the address-ish bit.
        if (looksLikeAddress(noTime)) {
          candidate = noTime;
        } else {
          // Attempt 2: address is in the next 1-3 lines (common in OCR where STOP and address split)
          for (let k = 1; k <= 3 && (i + k) < linesRaw.length; k++) {
            let look = linesRaw[i + k];
            if (!look) continue;
            if (ignoreLineRe.test(look)) continue;
            look = normalizeSlashes(look);
            look = stripBracketDir(look);
            look = stripTrailingPickupCount(look);

            // Avoid picking up student names: they are often "LAST FIRST" without street type/number
            // We'll require it to look like address
            if (looksLikeAddress(look)) { candidate = look; break; }
          }
        }

        if (!candidate) continue;

        candidate = cleanLine(candidate);
        candidate = normalizeSlashes(candidate);       // KEEP slashes, just normalize spacing
        candidate = stripBracketDir(candidate);
        candidate = stripTrailingPickupCount(candidate);
        candidate = normalizeIntersection(candidate);

        if (!candidate) continue;
        if (ignoreDepot && looksLikeDepotText(candidate)) continue;

        // Append default place if not present
        candidate = appendDefaultPlace(candidate, defaultPlace);

        const key = candidate.toLowerCase();
        if (seen.has(key)) continue;
        seen.add(key);
        out.push(candidate);
      }

      return out;
    }

    function encodeForPath(s) {
      return encodeURIComponent(s).replace(/%20/g, "+");
    }

    function setAnalyzeEnabled() {
      els.analyze.disabled = !(els.files.files && els.files.files.length > 0);
    }

    els.files.addEventListener('change', () => {
      setAnalyzeEnabled();
      els.raw.value = "";
      els.stops.value = "";
      els.build.disabled = true;
      els.open.disabled = true;
      els.url.textContent = "";
      els.routeNote.textContent = "";
      els.limitNote.textContent = "";
      setProgress(0, "Ready");
    });

    async function requestLocation() {
      els.geoStatus.textContent = "Requesting location permission…";
      if (!navigator.geolocation) {
        els.geoStatus.innerHTML = `<span class="warn">Geolocation not supported in this browser.</span>`;
        return;
      }
      const tryGet = (options) => new Promise((resolve, reject) => {
        navigator.geolocation.getCurrentPosition(resolve, reject, options);
      });

      try {
        const pos = await tryGet({ enableHighAccuracy: true, timeout: 12000, maximumAge: 15000 });
        els.start.value = `${pos.coords.latitude},${pos.coords.longitude}`;
        els.geoStatus.innerHTML = `<span class="ok">Location set.</span>`;
        return;
      } catch (_) {}

      try {
        const pos = await tryGet({ enableHighAccuracy: false, timeout: 15000, maximumAge: 0 });
        els.start.value = `${pos.coords.latitude},${pos.coords.longitude}`;
        els.geoStatus.innerHTML = `<span class="ok">Location set.</span>`;
      } catch (e) {
        let msg = "Location denied/unavailable.";
        if (e && typeof e.code === "number") {
          if (e.code === 1) msg = "Location permission denied.";
          if (e.code === 2) msg = "Location unavailable.";
          if (e.code === 3) msg = "Location timed out.";
        }
        const isFile = window.location.protocol === "file:";
        els.geoStatus.innerHTML =
          `<span class="warn">${msg}${isFile ? " (Tip: open via https (GitHub Pages) or http://localhost for reliable GPS.)" : ""}</span>`;
      }
    }
    els.geo.addEventListener('click', requestLocation);

    els.analyze.addEventListener('click', async () => {
      const files = Array.from(els.files.files || []);
      if (!files.length) return;

      els.analyze.disabled = true;
      els.build.disabled = true;
      els.open.disabled = true;
      els.url.textContent = "";
      els.routeNote.textContent = "";
      els.limitNote.textContent = "";

      let combined = "";
      try {
        for (let i = 0; i < files.length; i++) {
          const f = files[i];
          setProgress(Math.round((i / files.length) * 100), `OCR image ${i+1} of ${files.length}…`);

          try {
            const { data } = await Tesseract.recognize(f, "eng", {
              logger: m => {
                if (m.status === "recognizing text") {
                  const base = (i / files.length) * 100;
                  const add = m.progress * (100 / files.length);
                  setProgress(Math.round(base + add), `OCR ${i+1}/${files.length}…`);
                }
              }
            });

            const txt = (data && data.text) ? data.text : "";
            if (txt.trim()) {
              combined += `\n\n----- IMAGE ${i+1} (${f.name}) -----\n` + txt;
            } else {
              combined += `\n\n----- IMAGE ${i+1} (${f.name}) -----\n` + "[NO TEXT DETECTED]";
            }
          } catch (err) {
            // Don't abort the whole run if one image fails on iOS; continue with the rest.
            combined += `\n\n----- IMAGE ${i+1} (${f.name}) -----\n` + `[OCR FAILED: ${String(err)}]`;
          }
        }

        els.raw.value = combined.trim();
        setProgress(100, "OCR complete. Extracting stops…");

        const stops = extractStopsFromText(combined, {
          defaultPlace: els.defaultPlace.value || "",
          ignoreDepot: els.ignoreDepot.checked,
          captureIntersections: els.captureIntersections.checked
        });

        els.stops.value = stops.join("\n");

        if (stops.length === 0) {
          els.status.textContent = "No stops detected. Tip: set Default city/state (e.g., Buffalo, NY) and try again.";
          els.build.disabled = true;
        } else {
          els.status.textContent = `Extracted ${stops.length} stop(s). Review/edit if needed (order preserved).`;
          els.build.disabled = false;
        }

        if (stops.length > 8) {
          els.limitNote.textContent =
            "Heads-up: Google Maps may fail if there are too many stops in one route link. If that happens, split into two routes (e.g., stops 1–8 and 9–end).";
        }
      } catch (e) {
        console.error(e);
        els.status.textContent = "OCR finished. If some pages show [OCR FAILED] in the raw output, try re-scanning those pages.";
      } finally {
        els.analyze.disabled = false;
        setAnalyzeEnabled();
      }
    });

    els.build.addEventListener('click', () => {
      const start = (els.start.value || "").trim();
      const dest = (els.dest.value || "").trim();
      const stops = els.stops.value.split(/\r?\n/).map(s => s.trim()).filter(Boolean);

      if (!start) {
        els.routeNote.innerHTML = `<span class="warn">Start is required. Click “Use my current location” or type a start address.</span>`;
        return;
      }
      if (stops.length === 0) {
        els.routeNote.innerHTML = `<span class="warn">No stops. Add at least one stop line.</span>`;
        return;
      }

      const partsRaw = [start, ...stops];
      if (dest) partsRaw.push(dest);

      const parts = partsRaw.map(encodeForPath);
      mapsUrl = "https://www.google.com/maps/dir/" + parts.join("/") + "?travelmode=driving";

      els.url.textContent = mapsUrl;
      els.open.disabled = false;
      els.routeNote.textContent = dest ? "Built route: Start → Stops → Destination (order preserved)." : "Built route: Start → Stops (order preserved).";
    });

    els.open.addEventListener('click', () => {
      if (!mapsUrl) return;
      window.open(mapsUrl, "_blank", "noopener,noreferrer");
    });

    setAnalyzeEnabled();
  </script>
</body>
</html>
