<!doctype html>
<html lang="en">
<head>
<link rel="manifest" href="manifest.json">
<meta name="theme-color" content="#0f0f0f">
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Route Sheet → Google Maps</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 16px; max-width: 980px; }
    h1 { margin: 0 0 10px; }
    .muted { color: #666; font-size: 13px; }
    .row { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    .card { border: 1px solid #ddd; border-radius: 12px; padding: 12px; }
    label { font-weight: 700; display: block; margin: 10px 0 6px; }
    input[type="text"], textarea { width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 10px; box-sizing: border-box; }
    textarea { min-height: 160px; }
    button { padding: 10px 12px; border: 0; border-radius: 10px; cursor: pointer; font-weight: 800; }
    button:disabled { opacity: .55; cursor: not-allowed; }
    .btns { display: flex; flex-wrap: wrap; gap: 10px; margin-top: 10px; }
    .progress { height: 10px; background: #eee; border-radius: 999px; overflow: hidden; }
    .bar { height: 100%; width: 0%; background: #111; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .small { font-size: 12px; }
    .pill { display: inline-block; padding: 2px 8px; border: 1px solid #ddd; border-radius: 999px; font-size: 12px; color: #444; }
    .warn { color: #8a3b00; font-size: 12px; }
    .ok { color: #0a6; font-size: 12px; }
  </style>
</head>
<script>
  if ("serviceWorker" in navigator) {
    navigator.serviceWorker.register("sw.js");
  }
</script>

<body>
  <h1>Route Sheet → Google Maps</h1>
  <p class="muted">
    Upload route sheet photos (multiple) → click Analyze → stops are extracted (order preserved) → open turn-by-turn in Google Maps.
  </p>

  <div class="row">
    <div class="card">
      <label>1) Upload route sheet photos (multiple)</label>
      <input id="files" type="file" accept="image/*" multiple />

      <div style="margin-top:10px;">
        <div class="progress"><div id="bar" class="bar"></div></div>
        <div id="status" class="muted small" style="margin-top:6px;">Idle</div>
      </div>

      <div class="btns">
        <button id="geo">Use my current location as start</button>
        <button id="analyze" disabled>Analyze (OCR + Extract)</button>
      </div>

      <p class="muted small">
        Notes:
        <br>• Stop order stays exactly as extracted (we do NOT reorder stops).
        <br>• Stops are extracted ONLY from <span class="mono">STOP_XX</span> → <span class="mono">ADDRESS:</span> lines.
        <br>• School + start-location addresses are ignored.
      </p>

      <div class="pill">Start (GPS or type)</div>
      <input id="start" type="text" placeholder="Click 'Use my current location' or type a start address" />
      <div id="geoStatus" class="muted small"></div>
    </div>

    <div class="card">
      <label>2) Destination (optional)</label>
      <input id="dest" type="text" value="" placeholder="Enter final destination (optional)" />

      <label style="margin-top:10px;">Stops (one per line, order preserved)</label>
      <textarea id="stops" placeholder="Stops will appear here after you click Analyze..."></textarea>

      <div class="btns">
        <button id="build" disabled>Build Google Maps Route</button>
        <button id="open" disabled>Open Google Maps</button>
      </div>

      <div style="margin-top:10px;">
        <div class="pill">Google Maps URL</div>
        <div id="url" class="mono small" style="margin-top:6px; word-break: break-all;"></div>
        <div id="routeNote" class="muted small"></div>
      </div>
    </div>
  </div>

  <div class="card" style="margin-top:12px;">
    <label>OCR Output (raw text from ALL images)</label>
    <textarea id="raw" placeholder="OCR text will show here after you click Analyze..."></textarea>
    <div id="limitNote" class="warn" style="margin-top:8px;"></div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
  <script>
    const els = {
      files: document.getElementById('files'),
      analyze: document.getElementById('analyze'),
      geo: document.getElementById('geo'),
      start: document.getElementById('start'),
      dest: document.getElementById('dest'),
      raw: document.getElementById('raw'),
      stops: document.getElementById('stops'),
      build: document.getElementById('build'),
      open: document.getElementById('open'),
      url: document.getElementById('url'),
      status: document.getElementById('status'),
      bar: document.getElementById('bar'),
      geoStatus: document.getElementById('geoStatus'),
      routeNote: document.getElementById('routeNote'),
      limitNote: document.getElementById('limitNote'),
    };

    let mapsUrl = "";

    function setProgress(pct, msg) {
      els.bar.style.width = `${Math.max(0, Math.min(100, pct))}%`;
      if (msg) els.status.textContent = msg;
    }

    function stripStopMarkers(s) {
      return (s || "")
        .replace(/\(\s*stop\s*#?\s*\d+\s*\)/ig, " ")
        .replace(/\[\s*stop\s*#?\s*\d+\s*\]/ig, " ")
        .replace(/\bstop\s*#?\s*\d+\b/ig, " ")
        .replace(/\bstop\s*:\s*\d+\b/ig, " ")
        .replace(/\s{2,}/g, " ")
        .trim();
    }

    function normalizeStreetTypes(s) {
      return (s || "")
        .replace(/\bStreet\b/ig, "St")
        .replace(/\bAvenue\b/ig, "Ave")
        .replace(/\bRoad\b/ig, "Rd")
        .replace(/\bBoulevard\b/ig, "Blvd")
        .replace(/\bDrive\b/ig, "Dr")
        .replace(/\bLane\b/ig, "Ln")
        .replace(/\bParkway\b/ig, "Pkwy")
        .replace(/\bCourt\b/ig, "Ct")
        .replace(/\bPlace\b/ig, "Pl")
        .replace(/\bTerrace\b/ig, "Ter");
    }

    function normalizeAddress(s) {
      s = stripStopMarkers(s);
      s = s.replace(/\*.*?\*/g, " ").replace(/\(.*?\)/g, " ");
      s = s.replace(/\s+/g, " ").trim();
      s = s.replace(/,?\s*(Buffaio|Bufialo|Bufalo)\b/ig, ", Buffalo");
      s = normalizeStreetTypes(s);
      s = s.replace(/\.+$/g, "").trim();

      // If Buffalo present but NY missing
      if (/\bBuffalo\b/i.test(s) && !/\bNY\b/i.test(s)) s += ", NY";
      // If neither present, don't force Buffalo/NY here (your OCR already includes it)
      return s.trim();
    }

    // ✅ NEW: parse STOP blocks only (your OCR format)
    function extractStopsFromText(rawText) {
      const text = (rawText || "").replace(/\r/g, "\n");

      // We only accept addresses that appear AFTER STOP_XX and on an "ADDRESS:" line.
      // Example:
      // STOP_01
      // ADDRESS: 985 William St, Buffalo, NY 14206
      const stopAddrRegex = /STOP_\d+\s*[\s\S]*?ADDRESS:\s*([^\n]+)/gi;

      // Also capture SCHOOL_ADDRESS and START_LOCATION so we can exclude if needed
      const schoolAddr = (text.match(/SCHOOL_ADDRESS:\s*([^\n]+)/i) || [])[1] || "";
      const startAddr  = (text.match(/START_LOCATION:\s*([\s\S]*?)(?:\n\S|$)/i) || [])[1] || "";
      // startAddr may include the next lines; extract a single address-ish line if present
      const startAddrLine = (startAddr.match(/(\d{1,6}[^,\n]*,[^\n]+)/) || [])[1] || "";

      const exclude = new Set(
        [schoolAddr, startAddrLine]
          .map(a => normalizeAddress(a))
          .filter(Boolean)
          .map(a => a.toLowerCase())
      );

      const found = [];
      const seen = new Set();

      for (const m of text.matchAll(stopAddrRegex)) {
        const addrLine = normalizeAddress(m[1] || "");
        if (!addrLine) continue;

        const key = addrLine.toLowerCase();
        if (exclude.has(key)) continue;          // ✅ ignores school/start location
        if (seen.has(key)) continue;             // de-dupe
        seen.add(key);
        found.push(addrLine);
      }

      return found;
    }

    function encodeForPath(s) {
      return encodeURIComponent(s).replace(/%20/g, "+");
    }

    function buildGoogleMapsDirUrl(start, stops, destOptional) {
      const partsRaw = [start, ...stops];
      if (destOptional && destOptional.trim()) partsRaw.push(destOptional.trim());
      const parts = partsRaw.map(encodeForPath);
      return "https://www.google.com/maps/dir/" + parts.join("/") + "?travelmode=driving";
    }

    function setAnalyzeEnabled() {
      els.analyze.disabled = !(els.files.files && els.files.files.length > 0);
    }

    els.files.addEventListener('change', () => {
      setAnalyzeEnabled();
      els.raw.value = "";
      els.stops.value = "";
      els.build.disabled = true;
      els.open.disabled = true;
      els.url.textContent = "";
      els.routeNote.textContent = "";
      els.limitNote.textContent = "";
      setProgress(0, "Ready");
    });

    // ✅ FIXED: bring back the 2-attempt method + better file:// message
    async function requestLocation() {
      els.geoStatus.textContent = "Requesting location permission…";

      if (!navigator.geolocation) {
        els.geoStatus.innerHTML = `<span class="warn">Geolocation not supported in this browser.</span>`;
        return;
      }

      const tryGet = (options) => new Promise((resolve, reject) => {
        navigator.geolocation.getCurrentPosition(resolve, reject, options);
      });

      try {
        const pos = await tryGet({ enableHighAccuracy: true, timeout: 12000, maximumAge: 15000 });
        els.start.value = `${pos.coords.latitude},${pos.coords.longitude}`;
        els.geoStatus.innerHTML = `<span class="ok">Location set.</span>`;
        return;
      } catch (_) {}

      try {
        const pos = await tryGet({ enableHighAccuracy: false, timeout: 15000, maximumAge: 0 });
        els.start.value = `${pos.coords.latitude},${pos.coords.longitude}`;
        els.geoStatus.innerHTML = `<span class="ok">Location set.</span>`;
      } catch (e) {
        let msg = "Location denied/unavailable.";
        if (e && typeof e.code === "number") {
          if (e.code === 1) msg = "Location permission denied.";
          if (e.code === 2) msg = "Location unavailable (desktop Wi-Fi/IP can fail).";
          if (e.code === 3) msg = "Location timed out.";
        }

        const isFile = window.location.protocol === "file:";
        els.geoStatus.innerHTML =
          `<span class="warn">${msg}${isFile ? " (You’re running file:// — browsers often block/times out location here. Use http://localhost for reliable GPS.)" : ""}</span>`;
      }
    }
    els.geo.addEventListener('click', requestLocation);

    els.analyze.addEventListener('click', async () => {
      const files = Array.from(els.files.files || []);
      if (!files.length) return;

      els.analyze.disabled = true;
      els.build.disabled = true;
      els.open.disabled = true;
      els.url.textContent = "";
      els.routeNote.textContent = "";
      els.limitNote.textContent = "";

      let combined = "";
      try {
        for (let i = 0; i < files.length; i++) {
          const f = files[i];
          setProgress(Math.round((i / files.length) * 100), `OCR image ${i+1} of ${files.length}…`);

          const { data } = await Tesseract.recognize(f, "eng", {
            logger: m => {
              if (m.status === "recognizing text") {
                const base = (i / files.length) * 100;
                const add = m.progress * (100 / files.length);
                setProgress(Math.round(base + add), `OCR ${i+1}/${files.length}: ${Math.round(m.progress*100)}%`);
              }
            }
          });

          combined += `\n\n----- IMAGE ${i+1} -----\n` + (data.text || "");
        }

        els.raw.value = combined.trim();
        setProgress(100, "OCR complete. Extracting stops…");

        const stops = extractStopsFromText(combined);
        els.stops.value = stops.join("\n");

        if (stops.length === 0) {
          els.status.textContent = "No STOP_XX → ADDRESS lines detected. (If your real sheet format differs, tell me and I’ll adjust.)";
          els.build.disabled = true;
        } else {
          els.status.textContent = `Extracted ${stops.length} stop(s). Review/edit if needed (order preserved).`;
          els.build.disabled = false;
        }

        if (stops.length > 8) {
          els.limitNote.textContent =
            "Heads-up: Google Maps may fail if there are too many stops in one route link. If that happens, split into two routes (e.g., stops 1–8 and 9–end).";
        }
      } catch (e) {
        console.error(e);
        els.status.textContent = "OCR failed. Try clearer images or higher contrast.";
      } finally {
        els.analyze.disabled = false;
        setAnalyzeEnabled();
      }
    });

    els.build.addEventListener('click', () => {
      const start = (els.start.value || "").trim();
      const dest = (els.dest.value || "").trim();
      const stops = els.stops.value.split(/\r?\n/).map(s => s.trim()).filter(Boolean);

      if (!start) {
        els.routeNote.innerHTML = `<span class="warn">Start is required. Click “Use my current location” or type a start address.</span>`;
        return;
      }
      if (stops.length === 0) {
        els.routeNote.innerHTML = `<span class="warn">No stops. Add at least one stop line.</span>`;
        return;
      }

      mapsUrl = buildGoogleMapsDirUrl(start, stops, dest);
      els.url.textContent = mapsUrl;
      els.open.disabled = false;

      els.routeNote.textContent =
        dest ? "Built route: Start → Stops → Destination (order preserved)." : "Built route: Start → Stops (order preserved).";
    });

    els.open.addEventListener('click', () => {
      if (!mapsUrl) return;
      window.open(mapsUrl, "_blank", "noopener,noreferrer");
    });

    setAnalyzeEnabled();
  </script>
</body>
</html>
